import{r as h,m as R,n as E,p as _,q as v,t as A,Q as U,M as k,H as j,u as I,A as L,P as N,S as P,F as x,v as M}from"./vendor-CTLkAQ17.js";var C=h.createContext(void 0),S=e=>{const t=h.useContext(C);if(!t)throw new Error("No QueryClient set, use QueryClientProvider to set one");return t},he=({client:e,children:t})=>(h.useEffect(()=>(e.mount(),()=>{e.unmount()}),[e]),R.jsx(C.Provider,{value:e,children:t})),O=h.createContext(!1),D=()=>h.useContext(O);O.Provider;function F(){let e=!1;return{clearReset:()=>{e=!1},reset:()=>{e=!0},isReset:()=>e}}var H=h.createContext(F()),Q=()=>h.useContext(H),q=(e,t)=>{(e.suspense||e.throwOnError||e.experimental_prefetchInRender)&&(t.isReset()||(e.retryOnMount=!1))},B=e=>{h.useEffect(()=>{e.clearReset()},[e])},K=({result:e,errorResetBoundary:t,throwOnError:r,query:s,suspense:a})=>e.isError&&!t.isReset()&&!e.isFetching&&s&&(a&&e.data===void 0||E(r,[e.error,s])),$=e=>{if(e.suspense){const r=a=>a==="static"?a:Math.max(a??1e3,1e3),s=e.staleTime;e.staleTime=typeof s=="function"?(...a)=>r(s(...a)):r(s),typeof e.gcTime=="number"&&(e.gcTime=Math.max(e.gcTime,1e3))}},z=(e,t)=>e.isLoading&&e.isFetching&&!t,G=(e,t)=>(e==null?void 0:e.suspense)&&t.isPending,y=(e,t,r)=>t.fetchOptimistic(e).catch(()=>{r.clearReset()});function V(e,t,r){var d,f,g,p,T;const s=D(),a=Q(),u=S(),n=u.defaultQueryOptions(e);(f=(d=u.getDefaultOptions().queries)==null?void 0:d._experimental_beforeQuery)==null||f.call(d,n),n._optimisticResults=s?"isRestoring":"optimistic",$(n),q(n,a),B(a);const i=!u.getQueryCache().get(n.queryHash),[o]=h.useState(()=>new t(u,n)),c=o.getOptimisticResult(n),l=!s&&e.subscribed!==!1;if(h.useSyncExternalStore(h.useCallback(b=>{const w=l?o.subscribe(_.batchCalls(b)):v;return o.updateResult(),w},[o,l]),()=>o.getCurrentResult(),()=>o.getCurrentResult()),h.useEffect(()=>{o.setOptions(n)},[n,o]),G(n,c))throw y(n,o,a);if(K({result:c,errorResetBoundary:a,throwOnError:n.throwOnError,query:u.getQueryCache().get(n.queryHash),suspense:n.suspense}))throw c.error;if((p=(g=u.getDefaultOptions().queries)==null?void 0:g._experimental_afterQuery)==null||p.call(g,n,c),n.experimental_prefetchInRender&&!A&&z(c,s)){const b=i?y(n,o,a):(T=u.getQueryCache().get(n.queryHash))==null?void 0:T.promise;b==null||b.catch(v).finally(()=>{o.updateResult()})}return n.notifyOnChangeProps?c:o.trackResult(c)}function de(e,t){return V(e,U)}function fe(e,t){const r=S(),[s]=h.useState(()=>new k(r,e));h.useEffect(()=>{s.setOptions(e)},[s,e]);const a=h.useSyncExternalStore(h.useCallback(n=>s.subscribe(_.batchCalls(n)),[s]),()=>s.getCurrentResult(),()=>s.getCurrentResult()),u=h.useCallback((n,i)=>{s.mutate(n,i).catch(v)},[s]);if(a.error&&E(s.options.throwOnError,[a.error]))throw a.error;return{...a,mutate:u,mutateAsync:a.mutate}}const W="2.77.0";let m="";typeof Deno<"u"?m="deno":typeof document<"u"?m="web":typeof navigator<"u"&&navigator.product==="ReactNative"?m="react-native":m="node";const J={"X-Client-Info":`supabase-js-${m}/${W}`},X={headers:J},Y={schema:"public"},Z={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},ee={},te=e=>{let t;return e?t=e:typeof fetch>"u"?t=I:t=fetch,(...r)=>t(...r)},se=()=>typeof Headers>"u"?j:Headers,re=(e,t,r)=>{const s=te(r),a=se();return async(u,n)=>{var i;const o=(i=await t())!==null&&i!==void 0?i:e;let c=new a(n==null?void 0:n.headers);return c.has("apikey")||c.set("apikey",e),c.has("Authorization")||c.set("Authorization",`Bearer ${o}`),s(u,Object.assign(Object.assign({},n),{headers:c}))}};function ne(e){return e.endsWith("/")?e:e+"/"}function ae(e,t){var r,s;const{db:a,auth:u,realtime:n,global:i}=e,{db:o,auth:c,realtime:l,global:d}=t,f={db:Object.assign(Object.assign({},o),a),auth:Object.assign(Object.assign({},c),u),realtime:Object.assign(Object.assign({},l),n),storage:{},global:Object.assign(Object.assign(Object.assign({},d),i),{headers:Object.assign(Object.assign({},(r=d==null?void 0:d.headers)!==null&&r!==void 0?r:{}),(s=i==null?void 0:i.headers)!==null&&s!==void 0?s:{})}),accessToken:async()=>""};return e.accessToken?f.accessToken=e.accessToken:delete f.accessToken,f}function ie(e){const t=e==null?void 0:e.trim();if(!t)throw new Error("supabaseUrl is required.");if(!t.match(/^https?:\/\//i))throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");try{return new URL(ne(t))}catch{throw Error("Invalid supabaseUrl: Provided URL is malformed.")}}class oe extends L{constructor(t){super(t)}}class ue{constructor(t,r,s){var a,u,n;this.supabaseUrl=t,this.supabaseKey=r;const i=ie(t);if(!r)throw new Error("supabaseKey is required.");this.realtimeUrl=new URL("realtime/v1",i),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",i),this.storageUrl=new URL("storage/v1",i),this.functionsUrl=new URL("functions/v1",i);const o=`sb-${i.hostname.split(".")[0]}-auth-token`,c={db:Y,realtime:ee,auth:Object.assign(Object.assign({},Z),{storageKey:o}),global:X},l=ae(s??{},c);this.storageKey=(a=l.auth.storageKey)!==null&&a!==void 0?a:"",this.headers=(u=l.global.headers)!==null&&u!==void 0?u:{},l.accessToken?(this.accessToken=l.accessToken,this.auth=new Proxy({},{get:(d,f)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(f)} is not possible`)}})):this.auth=this._initSupabaseAuthClient((n=l.auth)!==null&&n!==void 0?n:{},this.headers,l.global.fetch),this.fetch=re(r,this._getAccessToken.bind(this),l.global.fetch),this.realtime=this._initRealtimeClient(Object.assign({headers:this.headers,accessToken:this._getAccessToken.bind(this)},l.realtime)),this.rest=new N(new URL("rest/v1",i).href,{headers:this.headers,schema:l.db.schema,fetch:this.fetch}),this.storage=new P(this.storageUrl.href,this.headers,this.fetch,s==null?void 0:s.storage),l.accessToken||this._listenForAuthEvents()}get functions(){return new x(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}from(t){return this.rest.from(t)}schema(t){return this.rest.schema(t)}rpc(t,r={},s={head:!1,get:!1,count:void 0}){return this.rest.rpc(t,r,s)}channel(t,r={config:{}}){return this.realtime.channel(t,r)}getChannels(){return this.realtime.getChannels()}removeChannel(t){return this.realtime.removeChannel(t)}removeAllChannels(){return this.realtime.removeAllChannels()}async _getAccessToken(){var t,r;if(this.accessToken)return await this.accessToken();const{data:s}=await this.auth.getSession();return(r=(t=s.session)===null||t===void 0?void 0:t.access_token)!==null&&r!==void 0?r:this.supabaseKey}_initSupabaseAuthClient({autoRefreshToken:t,persistSession:r,detectSessionInUrl:s,storage:a,userStorage:u,storageKey:n,flowType:i,lock:o,debug:c},l,d){const f={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new oe({url:this.authUrl.href,headers:Object.assign(Object.assign({},f),l),storageKey:n,autoRefreshToken:t,persistSession:r,detectSessionInUrl:s,storage:a,userStorage:u,flowType:i,lock:o,debug:c,fetch:d,hasCustomAuthorizationHeader:Object.keys(this.headers).some(g=>g.toLowerCase()==="authorization")})}_initRealtimeClient(t){return new M(this.realtimeUrl.href,Object.assign(Object.assign({},t),{params:Object.assign({apikey:this.supabaseKey},t==null?void 0:t.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((r,s)=>{this._handleTokenChanged(r,"CLIENT",s==null?void 0:s.access_token)})}_handleTokenChanged(t,r,s){(t==="TOKEN_REFRESHED"||t==="SIGNED_IN")&&this.changedAccessToken!==s?(this.changedAccessToken=s,this.realtime.setAuth(s)):t==="SIGNED_OUT"&&(this.realtime.setAuth(),r=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}}const ge=(e,t,r)=>new ue(e,t,r);function ce(){if(typeof window<"u"||typeof process>"u")return!1;const e=process.version;if(e==null)return!1;const t=e.match(/^v(\d+)\./);return t?parseInt(t[1],10)<=18:!1}ce()&&console.warn("⚠️  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");export{he as Q,fe as a,S as b,ge as c,de as u};
